defmodule <%= @app_module %>.Repo.Migrations.CreateBillingTables do
  use Ecto.Migration

  def change do
    # Billable customers - polymorphic association to any billable entity
    create table(:billable_customers) do
      add :billable_id, :bigint, null: false
      add :billable_type, :string, null: false
      add :paddle_customer_id, :string
      add :trial_ends_at, :utc_datetime

      timestamps(type: :utc_datetime)
    end

    create unique_index(:billable_customers, [:billable_id, :billable_type])
    create index(:billable_customers, [:paddle_customer_id])

    # Products - subscription plans, one-time purchases, credit packages
    create table(:products) do
      add :paddle_product_id, :string
      add :paddle_price_id, :string
      add :name, :string, null: false
      add :slug, :string, null: false
      add :type, :string, null: false
      add :metadata, :map, default: %{}
      add :active, :boolean, default: true

      timestamps(type: :utc_datetime)
    end

    create unique_index(:products, [:slug])
    create index(:products, [:paddle_product_id])
    create index(:products, [:type])

    # Subscriptions - recurring billing
    create table(:subscriptions) do
      add :billable_customer_id, references(:billable_customers, on_delete: :delete_all), null: false
      add :product_id, references(:products, on_delete: :nilify_all)
      add :name, :string, null: false, default: "default"
      add :paddle_subscription_id, :string
      add :paddle_price_id, :string
      add :status, :string, null: false
      add :quantity, :integer, default: 1
      add :trial_ends_at, :utc_datetime
      add :paused_at, :utc_datetime
      add :current_period_start, :utc_datetime
      add :current_period_end, :utc_datetime
      add :canceled_at, :utc_datetime
      add :ends_at, :utc_datetime
      add :granted_by, :bigint
      add :grant_reason, :text

      timestamps(type: :utc_datetime)
    end

    create unique_index(:subscriptions, [:paddle_subscription_id], where: "paddle_subscription_id IS NOT NULL")
    create index(:subscriptions, [:billable_customer_id])
    create index(:subscriptions, [:status])
    create index(:subscriptions, [:billable_customer_id, :name])

    # Purchases - one-time transactions (products and credits)
    create table(:purchases) do
      add :billable_customer_id, references(:billable_customers, on_delete: :delete_all), null: false
      add :product_id, references(:products, on_delete: :nilify_all)
      add :paddle_transaction_id, :string
      add :status, :string, null: false

      # Credit tracking
      add :credits_granted, :integer, default: 0
      add :credits_remaining, :integer, default: 0
      add :credits_expire_at, :utc_datetime

      add :purchased_at, :utc_datetime, null: false
      add :refunded_at, :utc_datetime
      add :access_revoked_at, :utc_datetime
      add :granted_by, :bigint
      add :grant_reason, :text

      timestamps(type: :utc_datetime)
    end

    create unique_index(:purchases, [:paddle_transaction_id], where: "paddle_transaction_id IS NOT NULL")
    create index(:purchases, [:billable_customer_id])
    create index(:purchases, [:product_id])
    create index(:purchases, [:billable_customer_id, :status])

    # Add check constraints for credits (PostgreSQL only - SQLite doesn't support ALTER TABLE ADD CONSTRAINT)
    # Validation is handled at the application level in the schema for all databases
    create_constraint_if_postgres(:purchases, :credits_remaining_non_negative, check: "credits_remaining >= 0")
    create_constraint_if_postgres(:purchases, :credits_remaining_lte_granted, check: "credits_remaining <= credits_granted")

    # Credit spends - audit log for credit usage
    create table(:credit_spends) do
      add :billable_customer_id, references(:billable_customers, on_delete: :delete_all), null: false
      add :amount, :integer, null: false
      add :description, :string
      add :reference_type, :string
      add :reference_id, :bigint

      timestamps(type: :utc_datetime, updated_at: false)
    end

    create index(:credit_spends, [:billable_customer_id])
    create index(:credit_spends, [:reference_type, :reference_id])
  end

  # Create constraint only for PostgreSQL (SQLite doesn't support it)
  defp create_constraint_if_postgres(table, name, opts) do
    case repo_adapter() do
      Ecto.Adapters.Postgres -> create(constraint(table, name, opts))
      _ -> :ok
    end
  end

  defp repo_adapter do
    Application.get_env(:<%= @app_name %>, <%= @app_module %>.Repo)[:adapter]
  end
end
