defmodule <%= @app_module %>.FeatureFlags.Cache do
  @moduledoc """
  ETS-based cache for feature flags.

  Stores feature flags in an ETS table for fast lookups without database hits.
  The cache is refreshed periodically and can be manually refreshed when flags
  are updated.

  ## Configuration

      config :<%= @app_name %>, <%= @app_module %>.FeatureFlags,
        cache_refresh_interval: :timer.minutes(1)

  ## Usage

  The cache is started automatically as part of your application supervision tree.
  Use `<%= @app_module %>.FeatureFlags` context functions instead of accessing the cache directly.
  """

  use GenServer

  alias <%= @app_module %>.Repo
  alias <%= @app_module %>.FeatureFlags.Schemas.FeatureFlag

  @table_name :<%= @app_name %>_feature_flags
  @default_refresh_interval :timer.minutes(1)

  # ============================================================================
  # Client API
  # ============================================================================

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc """
  Looks up a feature flag by name from the cache.

  Returns the flag struct or nil if not found.
  """
  def get(name) when is_binary(name) do
    case :ets.lookup(@table_name, name) do
      [{^name, flag}] -> flag
      [] -> nil
    end
  rescue
    ArgumentError -> nil
  end

  @doc """
  Returns all cached feature flags.
  """
  def all do
    :ets.tab2list(@table_name)
    |> Enum.map(fn {_name, flag} -> flag end)
  rescue
    ArgumentError -> []
  end

  @doc """
  Refreshes the cache by reloading all flags from the database.
  """
  def refresh do
    GenServer.call(__MODULE__, :refresh)
  end

  # ============================================================================
  # Server Callbacks
  # ============================================================================

  @impl true
  def init(opts) do
    table = :ets.new(@table_name, [:named_table, :set, :public, read_concurrency: true])
    refresh_interval = Keyword.get(opts, :refresh_interval, refresh_interval())

    # Load flags on init - but handle case where repo isn't started yet
    load_flags(table)

    schedule_refresh(refresh_interval)

    {:ok, %{table: table, refresh_interval: refresh_interval}}
  end

  @impl true
  def handle_call(:refresh, _from, state) do
    load_flags(state.table)
    {:reply, :ok, state}
  end

  @impl true
  def handle_info(:refresh, state) do
    load_flags(state.table)
    schedule_refresh(state.refresh_interval)
    {:noreply, state}
  end

  # ============================================================================
  # Private
  # ============================================================================

  defp load_flags(table) do
    try do
      import Ecto.Query
      flags = Repo.all(from(f in FeatureFlag))
      :ets.delete_all_objects(table)

      Enum.each(flags, fn flag ->
        :ets.insert(table, {flag.name, flag})
      end)
    rescue
      _ -> :ok
    end
  end

  defp schedule_refresh(:infinity), do: :ok

  defp schedule_refresh(interval) do
    Process.send_after(self(), :refresh, interval)
  end

  defp refresh_interval do
    Application.get_env(:<%= @app_name %>, <%= @app_module %>.FeatureFlags, [])
    |> Keyword.get(:cache_refresh_interval, @default_refresh_interval)
  end
end
