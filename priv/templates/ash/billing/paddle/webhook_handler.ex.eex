defmodule <%= @app_module %>.Billing.Paddle.WebhookHandler do
  @moduledoc """
  Processes Paddle webhook events using Ash resources.
  """

  require Logger

  alias <%= @app_module %>.Billing.{Customers, Subscriptions, Purchases, Product}

  def handle_event(%{"event_type" => event_type, "data" => data}) do
    Logger.info("Processing Paddle webhook: #{event_type}")

    case event_type do
      "subscription.created" -> handle_subscription_created(data)
      "subscription.updated" -> handle_subscription_updated(data)
      "subscription.canceled" -> handle_subscription_canceled(data)
      "subscription.paused" -> handle_subscription_paused(data)
      "subscription.resumed" -> handle_subscription_resumed(data)
      "transaction.completed" -> handle_transaction_completed(data)
      "transaction.refunded" -> handle_transaction_refunded(data)
      _ ->
        Logger.debug("Ignoring unhandled Paddle event: #{event_type}")
        :ok
    end
  end

  def handle_event(_), do: {:error, :invalid_event}

  defp handle_subscription_created(data) do
    paddle_subscription_id = data["id"]
    paddle_customer_id = data["customer_id"]

    with {:ok, customer} <- Customers.get_or_create_by_paddle_id(paddle_customer_id),
         nil <- Subscriptions.get_by_paddle_id(paddle_subscription_id) do
      attrs = %{
        billable_customer_id: customer.id,
        paddle_subscription_id: paddle_subscription_id,
        paddle_price_id: get_price_id(data),
        product_id: get_product_id(data),
        status: normalize_status(data["status"]),
        quantity: get_quantity(data),
        current_period_start: parse_datetime(data["current_billing_period"]["starts_at"]),
        current_period_end: parse_datetime(data["current_billing_period"]["ends_at"]),
        trial_ends_at: parse_datetime(data["scheduled_change"]["effective_at"])
      }

      case Subscriptions.create_from_paddle(attrs) do
        {:ok, _} -> :ok
        {:error, reason} -> {:error, reason}
      end
    else
      %{} -> :ok
      {:error, reason} -> {:error, reason}
    end
  end

  defp handle_subscription_updated(data) do
    paddle_subscription_id = data["id"]

    case Subscriptions.get_by_paddle_id(paddle_subscription_id) do
      nil -> handle_subscription_created(data)
      subscription ->
        attrs = %{
          status: normalize_status(data["status"]),
          current_period_start: parse_datetime(data["current_billing_period"]["starts_at"]),
          current_period_end: parse_datetime(data["current_billing_period"]["ends_at"])
        }

        case Subscriptions.update_status(subscription, attrs) do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end

  defp handle_subscription_canceled(data) do
    paddle_subscription_id = data["id"]

    case Subscriptions.get_by_paddle_id(paddle_subscription_id) do
      nil -> :ok
      subscription ->
        attrs = %{
          status: "canceled",
          canceled_at: parse_datetime(data["canceled_at"]) || DateTime.utc_now(:second),
          ends_at: parse_datetime(data["scheduled_change"]["effective_at"])
        }

        case Subscriptions.update_status(subscription, attrs) do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end

  defp handle_subscription_paused(data) do
    paddle_subscription_id = data["id"]

    case Subscriptions.get_by_paddle_id(paddle_subscription_id) do
      nil -> :ok
      subscription ->
        case Subscriptions.update_status(subscription, %{
               status: "paused",
               paused_at: parse_datetime(data["paused_at"]) || DateTime.utc_now(:second)
             }) do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end

  defp handle_subscription_resumed(data) do
    paddle_subscription_id = data["id"]

    case Subscriptions.get_by_paddle_id(paddle_subscription_id) do
      nil -> :ok
      subscription ->
        case Subscriptions.update_status(subscription, %{
               status: normalize_status(data["status"]),
               paused_at: nil
             }) do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end

  defp handle_transaction_completed(data) do
    paddle_transaction_id = data["id"]
    paddle_customer_id = data["customer_id"]

    if subscription_transaction?(data) do
      :ok
    else
      with {:ok, customer} <- Customers.get_or_create_by_paddle_id(paddle_customer_id),
           nil <- Purchases.get_by_paddle_id(paddle_transaction_id) do
        product = get_product_from_transaction(data)

        credits =
          if product && product.type == "credits" do
            Product.credits_amount(product)
          else
            0
          end

        attrs = %{
          billable_customer_id: customer.id,
          paddle_transaction_id: paddle_transaction_id,
          product_id: product && product.id,
          status: "completed",
          credits_granted: credits,
          credits_remaining: credits,
          purchased_at: parse_datetime(data["created_at"]) || DateTime.utc_now(:second)
        }

        case Purchases.create_from_paddle(attrs) do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
      else
        %{} -> :ok
        {:error, reason} -> {:error, reason}
      end
    end
  end

  defp handle_transaction_refunded(data) do
    paddle_transaction_id = data["id"]

    case Purchases.get_by_paddle_id(paddle_transaction_id) do
      nil -> :ok
      purchase ->
        case Purchases.refund(purchase) do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end

  defp normalize_status("active"), do: "active"
  defp normalize_status("trialing"), do: "trialing"
  defp normalize_status("past_due"), do: "past_due"
  defp normalize_status("paused"), do: "paused"
  defp normalize_status("canceled"), do: "canceled"
  defp normalize_status(status), do: status

  defp parse_datetime(nil), do: nil

  defp parse_datetime(datetime_string) when is_binary(datetime_string) do
    case DateTime.from_iso8601(datetime_string) do
      {:ok, datetime, _offset} -> DateTime.truncate(datetime, :second)
      _ -> nil
    end
  end

  defp get_price_id(%{"items" => [%{"price" => %{"id" => price_id}} | _]}), do: price_id
  defp get_price_id(%{"items" => [%{"price_id" => price_id} | _]}), do: price_id
  defp get_price_id(_), do: nil

  defp get_quantity(%{"items" => [%{"quantity" => quantity} | _]}), do: quantity
  defp get_quantity(_), do: 1

  defp get_product_id(data) do
    case get_price_id(data) do
      nil ->
        nil

      price_id ->
        case Ash.get(<%= @app_module %>.Billing.Product, :get_by_paddle_price_id, %{paddle_price_id: price_id}) do
          {:ok, product} -> product.id
          _ -> nil
        end
    end
  end

  defp get_product_from_transaction(data) do
    case get_price_id(data) do
      nil ->
        nil

      price_id ->
        case Ash.get(<%= @app_module %>.Billing.Product, :get_by_paddle_price_id, %{paddle_price_id: price_id}) do
          {:ok, product} -> product
          _ -> nil
        end
    end
  end

  defp subscription_transaction?(%{"subscription_id" => sub_id}) when is_binary(sub_id), do: true
  defp subscription_transaction?(_), do: false
end
